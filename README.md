# rollup-plugin-datafile

‚ö†Ô∏è‚ö†Ô∏è Probably don't use this, it's, like, pre-alpha. But maybe eventually:

üç£ A Rollup plugin which imports files as inline data URLs or as external files, configurable per extension, path, name, etc., and even if they don't exist until build time.

Use-case of this plugin: 

* You want to import data from a file (binary data, JSON data, string data, whatever). Any external file. Possibly a wide array of different files.
* You want to control whether they're inlined or emitted as separate assets, whether their loading blocks the main thread or not, and have those settings controlled per extension, per file, etc.
* The file referenced may or may not exist at build-time (implying it could be generated by another plugin at build-time as a result of what's been `import`ed)

## Requirements

At least rollup@3 in order to build this plugin itself.

## Install

Using npm:

It's on Github only for now, but you can add a Github package to your `package.json` if you're feeling adventurous.

## Usage

Create a `rollup.config.js` [configuration file](https://www.rollupjs.org/guide/en/#configuration-files) and import the plugin:

```js
import datafile from 'rollup-plugin-datafile';

export default {
  input: 'src/index.js',
  output: {
    dir: 'output',
    format: 'cjs'
  },
  plugins: [datafile()]
};
```

Then call `rollup` either via the [CLI](https://www.rollupjs.org/guide/en/#command-line-reference) or the [API](https://www.rollupjs.org/guide/en/#javascript-api).

With an accompanying file `src/index.js`, the local `image.png` file would now be importable as seen below:

```js
import promiseToArrayBuffer from "datafile:./image.png?mode=array-buffer";
// Prefixing URLs with the string ^^^^^^^^^ will *forcibly* use this plugin
// on any file, disregarding the `include` and `exclude` options, which can be used
// if you don't want to specify this in the source file.

const arrayBuffer = await promiseToArrayBuffer;
```

You can also import from the root of the project:
```js
import imageFile from "datafile:~/src/assets/image.png" assert { mode: "array-buffer" }
```

Finally, if you don't want to prefix everything with `datafile:`, you can use the [standard `include` and `exclude` options](https://github.com/rollup/plugins/tree/master/packages/pluginutils#include-and-exclude) to manually pull in the files you want.

By default, most things imported via `datafile` are put in a flat `assets` directory with the name of the file. Change this behavior with the `transformFilePath` option (which by default returns `assets/${fileName}`, to be clear).

## Options

These options can be specified per extension, per file, per URL extension, and per import assertion:

* `location`: Can be one of:
    * `"inline"` (default): The asset is directly embedded in the file, using base64 depending on `mode` (which increases the file size not insubstantially).
    * `"asset"`: The asset is written to the output directory as a separate file (default path is `assets/${filename}`).
* `timing`: When you do `import data from "file.json"`, this controls whether `data` is a `Promise` to your data, the data itself, or a URL to the data. Can be one of:
    * `"async"` (default): The asset is loaded off the main thread using `fetch`. Especially if `location` is `"inline"`, this can be a good optimization over manually copying over base64 byte by byte on the main thread, but you will need an `await` at some point.
    * `"sync"`: The asset is loaded directly on the main thread. If `location` is `"asset"` the relative URL will be imported as the only way to synchronously import an external resource. This can be used in places like `<img src="">`.
* `mode`: One of `"text"` | `"json"` | `"blob"` | `"array-buffer"` | `"response"`. The import will either return a promise to one of these if `timing` is `"async"`, or it directly if `timing` is `"sync"` and `"location"` is `"inline"`. (If `location` is `"asset"` then the URL is returned as a string instead, and `mode` has no effect)
* `mime`: Only used when `location: "inline"` for base64 (which itself is mostly only useful for `mode: "blob"` anyway).

If you're loading an image to use in an `<img>` (or similar), either use `timing: "sync", location: "asset"`, or use [`URL.createObjectURL`](https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL_static) for other cases.

As mentioned, you can specify options via the file's:
* **extension** (e.g. every `.css` file), 
* **full path** (e.g. the file at `C:/[...]/file.png`)
* **import assertion** ("import this file with these settings")
* **import query param** (also "import this file with these settings")

### Per extension:

`datafile({fileTypes: { ".css": { mode: "text", location: "inline", mime: "text/css" } } })`

### Per full path:
`datafile({ fileOptions: (fullPathToFile) => { if (meetsSomeCondition(fullPathToFile)) { return { location: "inline"; } } } })`

### Per import assertion:
`import image from "datafile:somefile.png" assert { location: "inline" }`

### Per URL search param:
`import image from "datafile:somefile.png?location=inline"`

### Asset file locations
`transformFilePath` controls how any given asset is named in the output directory. See `TransformFilePathInfo` for the information this function is given; it should return a non-absolute, non-relative path that the file will be named. By default, it's `asset/${fileName}`

### Top-level await

The `useTopLevelAwait` setting can be used to allow imports to return their values instead of `Promise`s that can be awaited for those values.

Not currently recommended, as the way Rollup inlines modules means instead of `await`ing as many `Promise`s as possible at once, each `Promise` will be `await`ed individually, one-by-one.

## Synchronization

This plugin reads its files during `buildEnd`, which is as late as `emitAsset` can be called.

If you're importing a file that's created by another plugin during `buildEnd` itself, it may be necessary to tell this plugin to wait until that plugin has finished its `buildEnd`. To do this, within that plugin's runtime, search for this plugin and add a `Promise` to this plugin's `.api.promisesToWaitFor`, which is a `Set<Promise>`.  This plugin won't read any files until all of those `Promise`s resolve.
